# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/170ioqzLX0zinqgWUK56Jk3WhE2BMVgeD

**OBJECTIVE**


How have Dutch house prices evolved from 1995 to 2025, and how do trends differ across national, macroregional, provincial, and municipal levels?


Where have Dutch house prices grown the fastest between 1995 and 2025?
"""

# importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style="whitegrid")

# Loading dataset from source
df = pd.read_csv("housing.csv",sep=';')

# Data inspection
print(df.shape)
display(df.head(20))
display(df.info())

"""*Creating required additional columns and cleaning data*"""

# converting periods column to int by creating new 'Year' column
df['Year']=df['Periods'].str[:4].astype(int)


# Dropping spaces from Regions codes
df['Regions'] = df['Regions'].str.strip()


# classifying regions and creating a new column 'Region_type'
region_types = []

for x in df["Regions"]:
    if x.startswith("NL"):
        region_types.append("National")
    elif x.startswith("LD"):
        region_types.append("MacroRegion")
    elif x.startswith("PV"):
        region_types.append("Province")
    elif x.startswith("GM"):
        region_types.append("Municipality")
    else:
        region_types.append("Other")

df["Region_type"] = region_types
print(df["Region_type"].value_counts())


# Checking for missing data
print(df.isna().sum())


# Categorizing missingness by Region_type
print(df.groupby("Region_type")["AveragePurchasePrice_1"].apply(lambda x: x.isna().mean()))


# Removing rows where price is missing (Municipality level data)
df['AveragePurchasePrice_1'].isna().sum()
df = df.dropna(subset=['AveragePurchasePrice_1']).reset_index(drop=True)


# Rechecking for missing data and new columns
print(df.isna().sum())
print(df.head())

"""*National Housing Price Trend (1995–2024)*"""

# National yearly average price (nl_avg_price)
nl_avg_price = df[df['Region_type'] == 'National'].groupby('Year')['AveragePurchasePrice_1'].mean().sort_index()
print(nl_avg_price)

# Year on Year % Change in National yearly average price (nl_pct_change)
nl_pct_change = nl_avg_price.pct_change() * 100
print(nl_pct_change)

# Calculating average yearly increase
avg_increase = nl_avg_price.diff().mean()
print(f"Average yearly increase: €{avg_increase:,.0f}")

# How many times the average price has increased from 1995 to current
manifold_increase = (nl_avg_price.iloc[-1] - nl_avg_price.iloc[0]) / nl_avg_price.iloc[0]
print(f"The national average price increased by {manifold_increase:.2f}times from {nl_avg_price.index[0]} to {nl_avg_price.index[-1]}")

# Year with highest price (peak) & lowest price (trough)
peak_year = nl_avg_price.idxmax()
trough_year = nl_avg_price.idxmin()
peak_price = nl_avg_price.max()
trough_price = nl_avg_price.min()
print(f"The highest price was recorded in {peak_year} with a value of {peak_price:.2f} and the lowest price was recorded in {trough_year} with a value of {trough_price:.2f}")

# Years with slow avg price growth
diff = nl_avg_price.diff()
flat_years = diff[diff < 5000].dropna().sort_index()
print(f"Years with slow price growth: {flat_years}")

# National price trend line chart
plt.figure(figsize=(11,5))
sns.lineplot(data=nl_avg_price.reset_index(), x='Year', y='AveragePurchasePrice_1', marker='o')
plt.title('National Average Purchase Price Trend (1995-2025)')
plt.xlabel('Year')
plt.ylabel('Average Purchase Price')
plt.axvspan(1995, 2008, color='green', alpha=0.2, label='Growth Phase (1995-2008)')
plt.axvspan(2008, 2013, color='red', alpha=0.2, label='Decline/Stagnation Phase (2008-2013)')
plt.axvspan(2013, 2024, color='blue', alpha=0.2, label='Recovery/New Growth Phase (2013-2024)')
plt.legend()
plt.show()

# Turning points in National price trend data
turning_points = []
for i in range(2, len(nl_avg_price) - 1):
    prev0 = nl_avg_price.iloc[i - 2]
    prev = nl_avg_price.iloc[i - 1]
    curr = nl_avg_price.iloc[i]
    next = nl_avg_price.iloc[i + 1]
    year = nl_avg_price.index[i]
    if (curr > next) or (curr < prev) or (curr<prev0):
        year = nl_avg_price.index[i]
        turning_points.append((year, curr))
print("Turning points:")
for year, price in turning_points:
    print(f"{year}: €{price:,.0f}")

"""*Macroregion comparison (LD01–LD04)*"""

# Comparing the four Macroregions
ld = df.loc[df['Region_type'] == 'MacroRegion'].groupby(['Year','Regions'],as_index=False)['AveragePurchasePrice_1'].mean()
print(ld)

# Displaying the data on a line chart
plt.figure(figsize=(10,5))
sns.lineplot(data=ld,x="Year",y="AveragePurchasePrice_1",hue="Regions")
plt.title('Macroregion (LD) — average purchase price by Year')
plt.ylabel('Average purchase price (EUR)')
plt.xlabel('Year')
plt.legend(title='MacroRegion', loc='upper left')
plt.tight_layout()
plt.show()

"""*Province-level Analysis*"""

# choosing latest year available in province rows
latest_year = df.loc[df["Region_type"] == "Province","Year"].max()
print(latest_year)

# In the latest year, which provinces (regions) have the highest average purchase price?
prov_latest = (
    df.loc[(df["Region_type"] == "Province") & (df["Year"]== latest_year)]
    .groupby("Regions",as_index=False)['AveragePurchasePrice_1'].mean()
    .sort_values('AveragePurchasePrice_1',ascending=False)
    .reset_index(drop=True)
)
print(prov_latest)

# plotting a bar chart for province avg. prices in latest year
sns.barplot(data=prov_latest, x='AveragePurchasePrice_1', y='Regions', palette='viridis', hue='Regions',legend=False)
plt.title(f'Province average price — {latest_year}')
plt.xlabel('Average purchase price (EUR)')
plt.ylabel('Province code')
plt.tight_layout()
plt.show()

# Calculating % growth and CAGR for provinces
prov_avg = df.loc[df['Region_type']=='Province'].groupby(['Year','Regions'], as_index=False)['AveragePurchasePrice_1'].mean()

first = prov_avg.groupby('Regions').first().reset_index()
last = prov_avg.groupby('Regions').last().reset_index()

summary = pd.DataFrame()
summary ['Regions'] = first['Regions']
summary['first_year'] = first['Year']
summary['first_price'] = first['AveragePurchasePrice_1']
summary['last_year'] = last['Year']
summary['last_price'] = last['AveragePurchasePrice_1']

summary['pct_change'] = (summary['last_price'] - summary['first_price']) / summary['first_price'] * 100
summary['years'] = summary['last_year'] - summary['first_year']
summary['cagr'] = (summary['last_price'] / summary['first_price'])**(1 / summary['years']) - 1

summary = summary.sort_values('pct_change', ascending=False)
print(summary.head())
top5_growth = summary.nlargest(5, 'pct_change')['Regions']

# plotting a line chart to show price trend for top 5 fastest growing province
plt.figure(figsize=(11,5))
sns.lineplot(data=prov_avg[prov_avg['Regions'].isin(top5_growth)],
             x='Year', y='AveragePurchasePrice_1', hue='Regions', marker='o')
plt.title('Top 5 Fastest-Growing Provinces — Price Trend')
plt.ylabel('Average purchase price (EUR)')
plt.xlabel('Year')
plt.tight_layout()
plt.show()

# calculating Province volatility (year-to-year std dev) & most/least stable
prov_vol = prov_avg.groupby('Regions')['AveragePurchasePrice_1'].agg(['mean', 'std', 'count']).reset_index()
prov_vol = prov_vol.sort_values('std', ascending=False) #the top rows have highest volatility, bottom rows are most stable
most_volatile = prov_vol.head(5)
most_stable   = prov_vol.tail(5)

print("Most volatile provinces:")
print(most_volatile)

print("\nLeast volatile provinces:")
print(most_stable)

"""*Municipality level analysis*


"""

# Finding the snapshot_year where municipalities have the most non-missing prices
mun = df[df['Region_type'] == 'Municipality'].copy()
counts_by_year = mun.groupby('Year').size().reset_index(name='n')
snapshot_year = int(counts_by_year.sort_values('n', ascending=False).iloc[0]['Year'])
snapshot_year, counts_by_year.head(10)

# Top 15 most expensive & Top 15 cheapest municipalities (at snapshot_year)
mun_snapshot = mun[mun['Year'] == snapshot_year].groupby('Regions', as_index=False)['AveragePurchasePrice_1'].mean()
top15_exp = mun_snapshot.sort_values('AveragePurchasePrice_1', ascending=False).head(15)
top15_cheap = mun_snapshot.sort_values('AveragePurchasePrice_1', ascending=True).head(15)
print("Snapshot year:", snapshot_year)
display(top15_exp)
display(top15_cheap)

# Municipality fastest gainers (using first & last available data per municipality)
mun_first = (
    mun.sort_values('Year')
       .groupby('Regions')
       .first()
       .reset_index()[['Regions', 'Year', 'AveragePurchasePrice_1']]
       .rename(columns={
           'Year': 'first_year',
           'AveragePurchasePrice_1': 'first_price'}))
mun_last = (mun.sort_values('Year')
       .groupby('Regions')
       .last()
       .reset_index()[['Regions', 'Year', 'AveragePurchasePrice_1']]
       .rename(columns={
           'Year': 'last_year',
           'AveragePurchasePrice_1': 'last_price'}))

mun_growth = mun_first.merge(mun_last, on='Regions')
mun_growth = mun_growth[mun_growth['last_year'] > mun_growth['first_year']]

mun_growth['pct_change'] = ((mun_growth['last_price'] - mun_growth['first_price'])/ mun_growth['first_price'] * 100)

top_gainers = mun_growth.sort_values('pct_change', ascending=False).head(10)

display(top_gainers)

# Comparing fastest growing v/s expensive municipality
# Select two example municipalities
mun1 = top15_exp['Regions'].iloc[0]     # most expensive
mun2 = top_gainers['Regions'].iloc[0]  # fastest-growing
mun_subset = mun[mun['Regions'].isin([mun1, mun2])]

mun_ts = (mun_subset
    .groupby(['Year', 'Regions'], as_index=False)
    ['AveragePurchasePrice_1']
    .mean())

plt.figure(figsize=(10, 5))
sns.lineplot(
    data=mun_ts,
    x='Year',
    y='AveragePurchasePrice_1',
    hue='Regions',
    marker='o')
plt.title(f'Municipality housing price trends: {mun1} vs {mun2}')
plt.ylabel('Average purchase price (EUR)')
plt.tight_layout()
plt.show()

"""**Key takeaways**


1. *Long-term national trend*

Dutch house prices increased substantially over the last 30 years, with prices rising multiple times compared to the mid-1990s.

The national trend shows three distinct phases:
strong growth until ~2008,
stagnation/decline after the financial crisis,
renewed and accelerated growth from ~2013 onward.

This confirms that housing prices are cyclical, but the long-term direction has been clearly upward.


2.  *Regional differences persist*

Macroregions and provinces follow the national trend but at different price levels and growth speeds.

Even when overall trends are similar, regional gaps remain, indicating that location continues to play a major role in housing affordability.

3. *Provinces differ in growth and stability*

Some provinces experienced faster long-term growth than others, while a few showed higher volatility in prices over time.

This highlights that higher growth often comes with higher variability, an important consideration for buyers and policymakers.

4. *Municipality-level prices show the strongest heterogeneity*

Municipality-level analysis reveals very large differences in absolute price levels.

In the snapshot year with the best data coverage, the gap between the most expensive and cheapest municipalities is substantial.

This confirms that national or provincial averages can mask local housing market realities.

5. *Growth leaders are not always the most expensive municipalities*

Several municipalities with lower initial price levels experienced the fastest percentage growth over their available time span.

Conversely, traditionally expensive municipalities tend to remain expensive but often grow more steadily rather than explosively.

6. *Price level and growth tell different stories*

Comparing a high-price municipality with a fast-growing municipality shows clearly different long-term trajectories:

one reflects established, high-value markets,

the other reflects emerging or rapidly developing areas.

This demonstrates why it is important to analyze both price levels and growth dynamics, not just one metric.
"""